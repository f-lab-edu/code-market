@startuml
title Code-Market Architecture (Multi-Module)

skinparam componentStyle rectangle
skinparam packageStyle rectangle

actor Client

component "API Gateway" as APIGW
Client --> APIGW

' ========================
' MEMBER
' ========================
rectangle "Member Bounded Context" {

  package "member-interface" {
    component "MemberController"
  }

  package "member-application" {
    component "MemberService"
    component "AuthService"
  }

  package "member-domain" {
    component "MemberEntity" as MemberEntity
    component "PasswordPolicy"
    component "MemberRepository (Port)"
  }

  package "member-infra" {
    component "JpaMemberRepository"
    component "RedisTokenStore"
  }

  ' API Flow
  MemberController --> MemberService
  MemberController --> AuthService

  ' Application -> Domain
  MemberService --> MemberEntity
  MemberService --> PasswordPolicy
  MemberService --> "MemberRepository (Port)"

  ' Domain Port -> Infra Adapter
  "MemberRepository (Port)" <.. JpaMemberRepository

  ' Auth Infra
  AuthService --> RedisTokenStore
}

APIGW --> MemberController

' ========================
' PRODUCT
' ========================
rectangle "Product Bounded Context" {

  package "product-interface" {
    component "ProductController"
  }

  package "product-application" {
    component "ProductService"
  }

  package "product-domain" {
    component "ProductEntity" as ProductEntity
    component "StockPolicy"
    component "ProductRepository (Port)"
  }

  package "product-infra" {
    component "JpaProductRepository"
  }

  package "product-messaging" {
    component "ProductEventListener"
  }

  ' API Flow
  ProductController --> ProductService

  ' Application -> Domain
  ProductService --> ProductEntity
  ProductService --> StockPolicy
  ProductService --> "ProductRepository (Port)"

  ' Domain Port -> Infra Adapter
  "ProductRepository (Port)" <.. JpaProductRepository

  ' Messaging Adapter -> Application
  ProductEventListener --> ProductService
}

APIGW --> ProductController

' ========================
' INVENTORY (재고 BC)
' ========================
rectangle "Inventory Bounded Context" {

  package "inventory-interface" {
    ' Cart/Order에서 사용하는 재고 조회/예약용 포트
    component "InventoryAvailabilityApi"
    component "InventoryReservationApi"
  }

  package "inventory-application" {
    component "InventoryAvailabilityService"
    component "InventoryReservationService"
  }

  package "inventory-domain" {
    component "InventoryItem"
    component "InventoryPolicy"
    component "InventoryRepository (Port)"
  }

  package "inventory-infra" {
    component "JpaInventoryRepository"
  }

  ' Interface -> Application
  InventoryAvailabilityApi --> InventoryAvailabilityService
  InventoryReservationApi --> InventoryReservationService

  ' Application -> Domain
  InventoryAvailabilityService --> InventoryItem
  InventoryAvailabilityService --> InventoryPolicy
  InventoryAvailabilityService --> "InventoryRepository (Port)"

  InventoryReservationService --> InventoryItem
  InventoryReservationService --> InventoryPolicy
  InventoryReservationService --> "InventoryRepository (Port)"

  ' Domain Port -> Infra Adapter
  "InventoryRepository (Port)" <.. JpaInventoryRepository
}

' ========================
' CART
' ========================
rectangle "Cart Bounded Context" {

  package "cart-interface" {
    component "CartController"
  }

  package "cart-application" {
    component "CartService"
  }

  package "cart-domain" {
    component "CartEntity" as CartEntity
  }

  package "cart-infra" {
    component "RedisCartRepository"
  }

  ' API Flow
  CartController --> CartService

  ' Application -> Domain/Infra
  CartService --> CartEntity
  CartService --> RedisCartRepository

  ' Cart -> Inventory (재고 확인용 의존)
  CartService --> InventoryAvailabilityApi : check availability
}

APIGW --> CartController

' ========================
' ORDER
' ========================
rectangle "Order Bounded Context" {

  package "order-interface" {
    component "OrderController"
  }

  package "order-application" {
    component "OrderService"
  }

  package "order-domain" {
    component "OrderEntity" as OrderEntity
    component "OrderPolicy"
    component "OrderRepository (Port)"
    component "OrderEventPublisher (Port)"
  }

  package "order-infra" {
    component "JpaOrderRepository"
    component "KafkaOrderEventPublisher"
  }

  package "order-messaging" {
    component "OrderEventListener"
  }

  ' API Flow
  OrderController --> OrderService

  ' Application -> Domain
  OrderService --> OrderEntity
  OrderService --> OrderPolicy
  OrderService --> "OrderRepository (Port)"
  OrderService --> "OrderEventPublisher (Port)"

  ' Domain Port -> Infra Adapters
  "OrderRepository (Port)" <.. JpaOrderRepository
  "OrderEventPublisher (Port)" <.. KafkaOrderEventPublisher

  ' Messaging Adapter -> Application
  OrderEventListener --> OrderService

  ' Order -> Inventory (재고 예약/해제 의존)
  OrderService --> InventoryReservationApi : reserve/release stock
}

APIGW --> OrderController

' ========================
' PAYMENT
' ========================
rectangle "Payment Bounded Context" {

  package "payment-application" {
    component "PaymentService"
  }

  package "payment-domain" {
    component "PaymentEntity" as PaymentEntity
    component "PaymentValidator"
    component "PaymentEventPublisher (Port)"
  }

  package "payment-infra" {
    component "PgClient" as PgClient
    component "KafkaPaymentEventPublisher"
  }

  package "payment-messaging" {
    component "PaymentEventListener"
  }

  ' Application -> Domain
  PaymentService --> PaymentEntity
  PaymentService --> PaymentValidator
  PaymentService --> PgClient
  PaymentService --> "PaymentEventPublisher (Port)"

  ' Domain Port -> Infra Adapter
  "PaymentEventPublisher (Port)" <.. KafkaPaymentEventPublisher

  ' Messaging Adapter -> Application
  PaymentEventListener --> PaymentService
}

' ========================
' KAFKA
' ========================
component "Kafka Broker" as Kafka

' Order -> Payment
KafkaOrderEventPublisher --> Kafka : OrderCreatedEvent
Kafka --> PaymentEventListener : consume OrderCreatedEvent

' Payment -> Order
KafkaPaymentEventPublisher --> Kafka : PaymentCompletedEvent\nPaymentFailedEvent
Kafka --> OrderEventListener : consume PaymentCompletedEvent\nPaymentFailedEvent

' Payment -> Product
Kafka --> ProductEventListener : consume PaymentCompletedEvent

@enduml
